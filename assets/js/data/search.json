[ { "title": "我的第一篇博文", "url": "/posts/first-post/", "categories": "随笔", "tags": "生活", "date": "2022-03-27 02:34:00 +0000", "snippet": "大标题～Hello//代码片段int main(){ hello world;}" }, { "title": "你好，世界！", "url": "/posts/hello-world/", "categories": "随笔", "tags": "生活", "date": "2022-03-26 02:34:00 +0000", "snippet": "感谢关注～这里可以放代码片段噢～//代码片段int main(){ hello world;}" }, { "title": "Lanqiaocup Changearr", "url": "/posts/LanQiaoCup-ChangeArr/", "categories": "", "tags": "", "date": "2022-03-20 00:00:00 +0000", "snippet": "修改数组时间限制: 1.0s 内存限制: 256.0MB 本题总分：20 分【问题描述】给定一个长度为 N 的数组 A = [A1, A2, · · · AN]，数组中有可能有重复出现的整数。现在小明要按以下方法将其修改为没有重复整数的数组。小明会依次修改A2, A3, · · · , AN。当修改 Ai 时，小明会检查 Ai 是否在 A1 ～ Ai-1 中出现过。如果出现过，则小明会给 Ai 加上 1 ；如果新的 Ai 仍在之前出现过，小明会持续给 Ai 加 1 ，直到 Ai 没有在 A1 ～ Ai-1 中出现过。当 AN 也经过上述修改之后，显然 A 数组中就没有重复的整数了。现在给定初始的 A 数组，请你计算出最终的 A 数组。【输入格式】第一行包含一个整数 N。第二行包含 N 个整数 A1, A2, · · · , AN 。【输出格式】输出 N 个整数，依次是最终的 A1, A2, · · · , AN。【样例输入】52 1 1 3 4【样例输出】2 1 3 4 5【评测用例规模与约定】对于 80% 的评测用例，1 ≤ N ≤ 10000。对于所有评测用例，1 ≤ N ≤ 100000，1 ≤ Ai ≤ 1000000。解题思路bool标记每次+1很容易就t了（如果有N个数，全都为N，那么这是O(n^2/2）的复杂度，当n=1e5时就已经超时了）。这题可以巧妙地利用并查集。 我们初始化i的父亲为i，然后依次遍历输入的数组，使a[i] = getf(a[i]),再令f(a[i]) = getf(a[i]+1)即可。假如我们连续输入1，2,1，第一次输入1，a[1] = getf(1) = 1,更新f[1] = getf(a[1]+1) = 2； 第二次输入 输入2，a[2] = getf(2) =2,更新f[2] = getf(a[2]+1） = 3，第三次 再输入1，a[3] = getf(1) = getf(2） = 3， 这时候a[3]便等于3了，而这种 查 的时间复杂度仅为O( logn)。 很巧妙 好好体会。整体时间复杂度O(nlognlogn)。#include&lt;iostream&gt;#include&lt;bits/stdc++.h&gt;#define MaxNum 100001using namespace std;int f[MaxNum], a[MaxNum];int getf(int x){\treturn f[x] = f[x] == x? x:getf(f[x]);}int main(){\tint n;\tscanf(\"%d\", &amp;n);\tfor(int i = 1; i &lt;= MaxNum; i++)\t{\t\tf[i] = i;\t}\tfor(int i = 0; i &lt; n; i++)\t{\t\tscanf(\"%d\",&amp;a[i]);\t\ta[i] = getf(a[i]);\t\tf[a[i]] = getf(a[i] + 1); // 类似于union操作,根为下一个满足f[x] == x的x \t}\tfor(int i = 0 ; i &lt; n; i++)\t{\t\tcout &lt;&lt; a[i];\t\tif(i != n-1)\t\t{\t\t\tcout &lt;&lt; \" \";\t\t}\t}\treturn 0;}————————————————原文链接：https://blog.csdn.net/weixin_42765557/article/details/89480557" }, { "title": "Gan01", "url": "/posts/GAN01/", "categories": "", "tags": "", "date": "2022-03-20 00:00:00 +0000", "snippet": "GAN炼丹师blog01前言为了当一个有水平的炼丹师，从今天起决定把每次的炼丹过程给记录下来，毕竟炼丹一部分靠知识储备，再有一部分就是靠经验了经验1.今天弄明白了如何用keras实现将G和D连接起来训练G的时候，将D的参数进行锁住，在返回完整GAN网络（G与D连接起来）时，将GAN中的D模型的trainable参数设置为false，然后在GAN模型构造函数外对GAN进行compile（有博客说不这样的话任何地方的D模型的trainable参数都是false），这样的话只有在GAN中的D的trainable才是false，其余地方都是true2.再一个就是昨天看过李宏毅介绍GAN时，讲到训练D的时候多训练几轮，然后训练一次G（一个就够了），这样效果会好，我在这样进行之后效果确实好很多，一开始G的loss就降的很快，但是1w5次epoch之后loss就很难下降了。于是我决定当D的准确率小于60的时候，我才让D每回多训练两次，结果是2每当D的acc小于60后，下一次D的acc都会突增到70多，然后再迭代几次又掉下60，又重复上面的过程，这样迭代3w次，效果不如上面直接每次都先训练3次D（不知道是训练次数少的原因—毕竟这样做迭代3w次的话平均每一个epoch就少训练了至少1.5次D，还是说我这种想法的问题）下面是每次都训练3次D然后训练一个G的生成图片构成的动图:下面则是我设置之后的训练gif：" }, { "title": "Leetcode21", "url": "/posts/LeetCode21/", "categories": "", "tags": "", "date": "2022-03-17 00:00:00 +0000", "snippet": "LeetCode [21. 合并两个有序链表]题目描述将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。个人题解类似于归并排序，依此比较链表头的数值大小，来决定返回的链表具体代码class Solution {public: ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) { if(!list1) { return list2; } if(!list2) { return list1; } ListNode * head, *tail; if(list1-&gt;val &lt; list2-&gt;val) { head = tail = list1; list1 = list1-&gt;next; } else { head = tail = list2; list2 = list2-&gt;next; } while(list1 &amp;&amp; list2) { if(list1-&gt;val &lt; list2-&gt;val) { tail-&gt;next = list1; tail = list1; list1 = list1-&gt;next; } else { tail-&gt;next = list2; tail = list2; list2 = list2-&gt;next; } } if(!list1) { tail-&gt;next = list2; } if(!list2) { tail-&gt;next = list1; } return head; }};算法优化/代码改进这里题解给出了递归的解法，即每次比较链表头部来进行递归操作class Solution {public: ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) { if (l1 == nullptr) { return l2; } else if (l2 == nullptr) { return l1; } else if (l1-&gt;val &lt; l2-&gt;val) { l1-&gt;next = mergeTwoLists(l1-&gt;next, l2); return l1; } else { l2-&gt;next = mergeTwoLists(l1, l2-&gt;next); return l2; } }};" }, { "title": "Leetcode14", "url": "/posts/LeetCode14/", "categories": "", "tags": "", "date": "2022-03-17 00:00:00 +0000", "snippet": "LeetCode [14. 最长公共前缀]题目描述编写一个函数来查找字符串数组中的最长公共前缀。如果不存在公共前缀，返回空字符串 ““。示例 1：输入：strs = [“flower”,”flow”,”flight”]输出：”fl”示例 2：输入：strs = [“dog”,”racecar”,”car”]输出：””解释：输入不存在公共前缀。个人题解纵向扫描：遍历i次strs，第i次判断每个str的第i个字符是否相同，相同则加入到答案字符串中，不同则直接返回答案字符串具体代码class Solution {public: string longestCommonPrefix(vector&lt;string&gt;&amp; strs) { string ans = \"\"; bool flag = 1; char c; int num = strs.size(); for(int i = 0; i &lt; 200; i++) // 匹配第i个字符 { if(i &gt;= strs[0].length()) { return ans; } c = strs[0][i]; for(int j = 0; j &lt; num; j++) // 每个字符串匹配该字符 { if(i &gt;= strs[j].length() || strs[j][i] != c) { return ans; } } ans += c; } return ans; }};算法优化/代码改进这里题解给了两个更犀利的算法，虽然效率没提高多少，但是也是一种算法思想，可以参考一下1.分治算法: 题目查找的条件符合分治策列，则可以将strs分每次分为两组，求两组的公共前缀，实现“分”，然后再将两组的公共前缀进行求公共前缀，实现“合”，这是一个递归过程2.二分查找，显然，最长公共前缀的长度不会超过字符串数组中的最短字符串的长度。用 minLength 表示字符串数组中的最短字符串的长度，则可以在 [0,\\textit{minLength}][0,minLength] 的范围内通过二分查找得到最长公共前缀的长度。每次取查找范围的中间值mid，判断每个字符串的长度为 mid 的前缀是否相同，如果相同则最长公共前缀的长度一定大于或等于mid，如果不相同则最长公共前缀的长度一定小于mid，通过上述方式将查找范围缩小一半，直到得到最长公共前缀的长度。" }, { "title": "Leetcode13", "url": "/posts/LeetCode13/", "categories": "", "tags": "", "date": "2022-03-17 00:00:00 +0000", "snippet": "LeetCode 13.罗马数字题目描述罗马数字包含以下七种字符: I， V， X， L，C，D 和 M。字符 数值I 1V 5X 10L 50C 100D 500M 1000例如， 罗马数字 2 写做 II ，即为两个并列的 1 。12 写做 XII ，即为 X + II 。 27 写做 XXVII, 即为 XX + V + II 。通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。给定一个罗马数字，将其转换成整数。个人题解​\t分析完题意，特例也就是从左往右遍历字符串s的时候，一个字符表示的数比其右边字符表示的数要小，此时两个字符一起代表一个数，大小为右数 - 左数​\t如此，只需要双指针遍历字符串，当一个字符比其右边字符小时，加上其差值，否则直接加上该字符的值，遍历完返回累积和即可。具体代码class Solution {public: int getNum(char c) // 获取字符对应的数字 { switch(c) { case 'I': return 1; break; case 'V': return 5; break; case 'X': return 10; break; case 'L': return 50; break; case 'C': return 100; break; case 'D': return 500; break; case 'M': return 1000; break; default: return 0; break; } } int cmp(char a, char b) // 比较字符对应数字的大小,a &gt;= b返回1, { if(a == b) { return 1; } char s[7] = {'I', 'V', 'X','L' ,'C' ,'D' ,'M'}; for(int i = 0; i &lt; 7; i++) { if(s[i] == a) { return -1; } if(s[i] == b) { return 1; } } return 0; } int romanToInt(string s) { int len = s.length(); if(len == 1) { return getNum(s[0]); } int i = 0, j = 1; // 双指针 int ans = 0; while(i &lt; len &amp;&amp; j &lt; len) { if(cmp(s[i], s[j]) &gt; 0) { ans += getNum(s[i]); i++; j++; } else { ans += (getNum(s[j]) - getNum(s[i])); i += 2; j += 2; } } if(i &lt; len) { ans += getNum(s[i]); } return ans; }};代码改进首先是用来查询一个字符对应的数字的数据结构，这里用unordered_map更好，内部使用hashmap实现的，可以快速查找，缺点就是可能会耗费较多的内存空间再就是遍历字符串的过程，可以不用双指针，直接将遍历过程定义为，如果出现特例情况，则直接减去对应的数字值即可，这样代码更为精简class Solution {private: unordered_map&lt;char, int&gt; symbolValues = { {'I', 1}, {'V', 5}, {'X', 10}, {'L', 50}, {'C', 100}, {'D', 500}, {'M', 1000}, };public: int romanToInt(string s) { int ans = 0; int n = s.length(); for (int i = 0; i &lt; n; ++i) // 遍历字符串 { int value = symbolValues[s[i]]; if (i &lt; n - 1 &amp;&amp; value &lt; symbolValues[s[i + 1]]) // 特里情况减，否则加 { ans -= value; } else { ans += value; } } return ans; }};" }, { "title": "Leetcode09", "url": "/posts/LeetCode09/", "categories": "", "tags": "", "date": "2022-03-15 00:00:00 +0000", "snippet": "LeetCode 9.回文数题目描述：给你一个整数 x ，如果 x 是一个回文整数，返回 true ；否则，返回 false 。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。例如，121 是回文，而 123 不是。个人题解：​\t首先第一个想法就是将整数x转化为字符串，然后通过判断回文字符串的方式来轻松解决问题，但是这种解决办法有个弊端： 要用到to_string()函数，有时候答题环境不支持该函数，则该解法无效​\t然后根据题解学到了一种更为巧妙的解法：将数字的后半部分翻转再与前半部分进行比较，如果相同则为回文数​\t具体过程为：​\t1.先处理几种x肯定不是回文数的特殊情况：+ x小于0+ x不为0的同时x的个位为0（x的最高位不能为0）​ 2.再将将数字的后半部分翻转再与前半部分进行比较具体代码为:class Solution {public: bool isPalindrome(int x) { // 特殊情况： // 如上所述，当 x &lt; 0 时，x 不是回文数。 // 同样地，如果数字的最后一位是 0，为了使该数字为回文， // 则其第一位数字也应该是 0 // 只有 0 满足这一属性 if (x &lt; 0 || (x % 10 == 0 &amp;&amp; x != 0)) { return false; } int revertedNumber = 0; while (x &gt; revertedNumber) { revertedNumber = revertedNumber * 10 + x % 10; // 反转获得的数字（通过乘以10然后加上x的末位来获得反转后的数字) x /= 10; // 去除x的末位 } // 当数字长度为奇数时，我们可以通过 revertedNumber/10 去除处于中位的数字。 // 例如，当输入为 12321 时，在 while 循环的末尾我们可以得到 x = 12，revertedNumber = 123， // 由于处于中位的数字不影响回文（它总是与自己相等），所以我们可以简单地将其去除。 return x == revertedNumber || x == revertedNumber / 10; }};" }, { "title": "MyTestBlog", "url": "/posts/my-test-blog/", "categories": "", "tags": "TeXt", "date": "2022-03-08 00:00:00 +0000", "snippet": "scanf的正则用法的常见问题 scanf(\"%d %d\",&amp;m,&amp;n); char a[256]; scanf(\"%[^\\n]%*c\",a); //输入为 //2 6\t//ABCDEFGH 12345如上，再scanf正则用法前,如果已经有输入,并且输入结尾会包含一个回车(换行符)，那么这个回车会作为后面一个scanf的输入，即将后面scanf的正则用法给取消了 解决该问题的办法就是再上一个读入结束后加一个getchar();将最后的回车吃掉；如下 scanf(\"%d %d\",&amp;m,&amp;n); getchar(); char a[256]; scanf(\"%[^\\n]%*c\",a);" } ]
